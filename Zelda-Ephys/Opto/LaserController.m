classdef LaserController < handle
    %Code which handles a laser outputs, connected to AO0 channel on a NIDAQ
    %board. 
    % allows to handle two Lasers in parallel.
%         methods:
%     --------
%     init:
% 	    loads Config and initiates DAQ 
%     generateWaveform:
% 	    get a line of waveform based on params (currently max voltage for each channel) 
%     issueWaveform: 
% 	    send out the waveform 
%     registerTrigger: 
% 	    called by optoExpt to say which digital is the trigger
%     calibrateLEDs: 
% 	    function to calibrate the power of LEDs you use.
%     power2Volt: 
% 	    function to convert the power values of the LED to volts. 
%     stop
%     delete. 

    properties
        ConfigPath; 
        laserCfg;
        daqSession;
        AO;
        volt2laserPower;
        hemispheres;
    end    
    methods
        function obj = LaserController()
            expPaths = dat.paths;  
            obj.ConfigPath = [expPaths.rigConfig '\' 'LaserConfig.mat'];
            obj.laserCfg = load(obj.ConfigPath); %load some configuration files               
            obj.daqSession = daq.createSession('ni');
            % for set up several channels 
            try
                obj.AO = obj.daqSession.addAnalogOutputChannel(obj.laserCfg.device, 0:1, 'Voltage');
                
            catch
                warning(['LaserController failed to initialise'])
            end                
            %Set to zero output if not already
             obj.daqSession.outputSingleScan([0,0]);
        end
        
        function voltage_traces = generateWaveform(obj,voltageChan0,voltageChan1)
            rate = obj.daqSession.Rate;
            rampUpDur = 0.05; % in ms
            flatDur = 1.5; % in ms
            rampDownDur = 0.35; % in ms
            voltage_trace1 = ([linspace(0,1,rampUpDur*rate)';ones(flatDur*rate,1);linspace(1,0,rampDownDur*rate)']*voltageChan0);
            voltage_trace2 = ([linspace(0,1,rampUpDur*rate)';ones(flatDur*rate,1);linspace(1,0,rampDownDur*rate)']*voltageChan1);
            voltage_traces = [voltage_trace1 voltage_trace2];
         
        end

        function issueWaveform(obj,V_IN)
               % V_IN is whatever is generated by voltage trace
%             disp('STARTING ISSUING WAVEFORM');
            obj.daqSession.queueOutputData(V_IN);
%             disp('QUEUED DATA');
            obj.daqSession.startBackground;
%             disp('STARTED BACKGROUND');
        end
        
        function registerTrigger(obj) %Any issued waveforms will wait for an input from this trigger
            pinID = [obj.laserCfg.device '/PFI0'];
            obj.daqSession.addTriggerConnection('external', pinID, 'StartTrigger');
        end
        
        function removeTrigger(obj)
            obj.daqSession.removeConnection(1);
        end
        
        
        function calibrateLEDs(obj,powerMeterChannel)
            ch = obj.daqSession.addAnalogInputChannel(obj.laserCfg.device, powerMeterChannel, 'Voltage');
            ch.TerminalConfig = 'SingleEnded';
            maxVoltage = 5;
            voltages = linspace(0, maxVoltage, 10);
            
            prompt = {'max range for power meter:','wavelength:'};
            answer = inputdlg(prompt);
            rate = obj.daqSession.Rate;
            
            for LED_id = 1:2
                msgbox(sprintf("press enter if LED %.0d is in power meter. ",LED_id));
                pause;
                for iV = 1:numel(voltages)
                    V = voltages(iV);
                    on_trace = V*ones(1*rate, 1); 
                    zero_trace = zeros(numel(on_trace),1);             
                
                    % decide which channel we will output on
                    if LED_id ==1
                        voltage_traces = [on_trace zero_trace]; 
                    elseif LED_id==2
                        voltage_traces = [zero_trace on_trace];
                    end 
                    
                    obj.daqSession.queueOutputData(voltage_traces); % output the desired Voltages; 
                    phdData_voltage{iV,LED_id} = obj.daqSession.startForeground();
                    aveData_voltage(iV,LED_id) = mean(phdData_voltage{iV,LED_id}(round(end/2):end));
                end
                obj.daqSession.outputSingleScan([0 0]); % to stop outputting voltage;
            end
            
            powerMeterRange = str2double(answer{1}); 
            figure; hold all; 
            % cacluate measured power from measured ao
            aveData_power = aveData_voltage/2*powerMeterRange; 
            plot(voltages, aveData_power);
            xlabel('laser control [V]');
            ylabel('Power [mW]');
            legend({'LED1','LED2'});
            % overwrite config.
            obj.laserCfg.calib.voltages = voltages; 
            obj.laserCfg.calib.power = aveData_power; 
            obj.laserCfg.calib.powerRange = powerMeterRange; 
            obj.laserCfg.calib.calibWavelength = answer{2}; 
            newconfig = obj.laserCfg;
            save(obj.ConfigPath,'-struct','newconfig');
            
            
        end 
       
        function v = power2volt(obj,desiredPower,LEDidx)           
            % making sure it is pulled flat when desiredPower is 0; 
            if desiredPower==0
                v = 0; 
            else
            
                volts = obj.laserCfg.calib.voltages;
                power = obj.laserCfg.calib.power(:,LEDidx);
                if desiredPower > max(power)
                    disp(LEDidx);
                    disp(max(power));
                    error('power desired outside of calibrated range');
                end            
                %Local interpolation from the calibration data
                v = interp1(power,volts,desiredPower);
            end
        end
        
        function stop(obj)
            obj.daqSession.stop;
        end
        
        function delete(obj)
            delete(obj.daqSession);
        end
        
    end
end
